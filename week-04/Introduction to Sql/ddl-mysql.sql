-- ********************************************************* START ****************************************************************
-- Data Definition Language (DDL) is a subset of SQL. 
-- It's the language used to create, read, update, and delete database schema. 
-- Before we can manipulate data, we need a schema. DDL builds that schema.

-- It's possible to build schema with database GUI tools. 
-- We could work an entire career without writing a line of DDL. 
-- That would be a shame, though. Behind the scenes, GUI tools generate and execute DDL. 
-- There's no magic to what they do. It's all DDL. 
-- When we learn DDL and eliminate the GUI intermediary, we benefit.

-- 1. Writing DDL gives us full control of all schema names and eliminates the verbose SQL generated by GUI tools. Hand-written DDL can be simple, clean, and beautiful.
-- 2. DDL is the best way to share schema with other developers. GUI-generated DDL can be confusing. Hand-written DDL doesn't have to be.
-- 3. DDL gives us another tool for software development automation. We can automate schema creation.
-- ****************************************************** Field Agent *************************************************************
-- To practice DDL, we need a schema. 
-- We'll build a database for tracking field agents -- government and secret agents deployed throughout the world on classified missions. 
-- First, we identify core concepts and their relationships.

-- Agency
	-- A government or secret organization tasked with collecting intelligence and acting on intelligence to achieve some goal. 
    -- Examples: CIA (U.S. Central Intelligence Agency), ASIS (Australian Secret Intelligence Service), Southern Reach (fictional agencies allowed), and ODIN (from the Archer cartoon series).
-- Location
	-- An agency headquarters, research site, safe house, or other facilities.
-- Field Agent
	-- An individual employed by an agency and deployed "in the field". They work to accomplish the agency's goals, possibly in secret.
-- Security Clearance
	-- A rating that determines how much secret information is revealed to an agent.
-- Alias
	-- Agents don't necessarily want to be publically known. An alias is an alternative persona and identity.
-- Mission
	-- An agent task with a planned goal, a start date, and an end date.
-- **************************************************** Create Database ***********************************************************
-- A database server can host many databases. Each database is a self-contained schema with tables, relationships, and security.
-- To create a database, execute the create database statement in Workbench. 
-- It's the create keyword, database, then a database name. Refresh the schema view to show the new database.
create database field_agent;

-- We can't add two databases with the same name.
-- To delete a database, execute the drop database statement.
drop database field_agent;

-- During early schema design, it's common to:
-- 1. Preemptively drop the database with the protective if exists clause. if exists prevents dropping a database that doesn't exist.
-- 2. Re-create the database.
-- 3. Switch context to the new database with a use statement so all schema statements that follow apply to the new database.
-- Caution!
-- This approach is only for schema design and development.
-- A `drop` statement is serious business.
drop database if exists field_agent;
create database field_agent;
use field_agent;
-- ****************************************************** Create Table ************************************************************
-- To create a table, first ensure that we're in the correct database with the use statement. Then execute the create table statement.
-- Caution!
drop database if exists field_agent;
create database field_agent;

-- Always `use` the intended database.
use field_agent;

-- create tables and relationships
create table agency (
    agency_id int primary key auto_increment,
    short_name varchar(25) not null,
    long_name varchar(250) not null
);

-- Generically, the create table statement is the keywords create table, followed by a table name, followed by one or more column definitions inside parentheses, separated by commas.
/*
create table [table name] (
    [column name 1] [data type] [(not )null]? [modifiers...]?,
    [column name 2] [data type] [(not )null]? [modifiers...]?,
    [column name 3] [data type] [(not )null]? [modifiers...]?,
    [column name n] [data type] [(not )null]? [modifiers...]?
);
*/
-- **************************************************** Column Definition *********************************************************
/*
A column definition is:

1. name (required)
2. data type (required)
3. null specification (optional): either null (null values are allowed) or not null (null values are not allowed). Defaults to null if not specified.
	Always include the specification. When omitted, it's impossible to know if the omission was intentional. The only time we omit is in a primary key column. It's impossible for a primary key to be null.
4. column modifiers (optional):

primary key: makes a single column the primary key. If a table's primary key spans multiple columns (a compound key), this modifier cannot be used.
auto_increment: only valid for integer key columns. One auto_increment column is allowed per table. The database generates sequential integer values when a value isn't provided. Values are guaranteed to be unique.
default [value]: assigns a default value to a field when a value isn't provided.
*/

-- ******************************************************* Drop Table *************************************************************
-- To delete a table, use the drop table statement. The optional if exists clause prevents a SQL error when the table doesn't exist.
drop table agency;
drop table if exists agency;
-- **************************************************** Inline Contraints *********************************************************
/*
Create a table for agency locations. One agency can have many locations. 
In a one-to-many relationship, include the primary key of the one as a foreign key in the many. 
Here, we include agency_id as a column in location and create a foreign key with the constraint clause.
*/
create table location (
    location_id int primary key auto_increment,
    `name` varchar(25) not null,
    address varchar(125) not null,
    city varchar(50) not null,
    country_code varchar(5) not null,
    postal_code varchar(15) not null,
    agency_id int not null,
    -- Examine the constraint clause:
    constraint fk_location_agency_id
        foreign key (agency_id)
        references agency(agency_id)
);
/*
It starts with the keyword constraint, followed by a name. 
Conventions differ, but here we preface the name with "fk" to indicate a foreign key, then mention the table and its foreign key column. 
All together: fk_location_agency_id.

The second line specifies the type of constraint: foreign key. 
There are several constraint types: primary keys, unique indexes, and foreign keys. 
Each type has its own syntax. 
Foreign key is followed by one or more columns from the current table, grouped with parentheses. 
The columns are linked to columns in a referenced table.

On the third line, the references clause names the linked table and columns.
*/
-- ****************************************************** Alter Tables ************************************************************
-- Add a table for agents. An agency has a one-to-many relationship with an agent.
create table agent (
    agent_id int primary key auto_increment,
    first_name varchar(25) not null,
    middle_name varchar(25) null,
    last_name varchar(25) not null,
    dob date null,
    identifier varchar(50) not null,
    activation_date date not null,
    is_active bit not null default 1,
    agency_id int not null,
    constraint fk_agent_agency_id
        foreign key (agency_id)
        references agency(agency_id),
    constraint uq_agent_identifier_agency_id
        unique (identifier, agency_id)
);
/*
It's common to name bridge tables by naming the tables involved in the relationship. 
The name agency_agent makes the relationship between agency and agent clear.

agency_id and agent_id are foreign keys, but together they're also a compound primary key. 
Their value combination must be unique. 
This prevents creating the same relationship twice.

We move the agency/agent-specific columns identifier, activation_date, and is_active into the bridge table. 
Those columns are facts about the relationship between an agency and an agent. 
We remove them from the agent table next.
*/

-- The agency-specific columns and constraints are no longer needed in the agent table. Use the alter table statement to remove them.
alter table agent 
    drop index uq_agent_identifier_agency_id,
    drop foreign key fk_agent_agency_id,
    drop column agency_id,
    drop column is_active,
    drop column activation_date,
    drop column identifier;

/*
Generically, the alter table statement is the keywords alter table followed by a table name. 
Then one or more modification clauses. Modifications can add columns or constraints, remove columns or constraints, or modify an existing column or constraint.
alter table [table name]
    drop [something],
    add [something],
    change [something],
    modify [something];
*/ 

/*
Schema modification requires analysis. 
It's not always possible to change or drop a database object -- something might depend on it. 
The order of operations matters.

Above, we drop the constraints uq_agent_identifier_agency_id and fk_agent_agency_id before we drop the agency_id and identifier columns. 
If we tried to drop the columns first, the statement would fail because the constraints depend on the columns. 
If we drop the constraints first, we're in the clear.

As long as we're making changes to agent, modify the first_name and last_name columns to accept 50 characters instead of 25. 
Then add a new column, height_in_inches.

Maybe we want to track an agent's physical characteristics. 
We've established agents aren't necessarily trustable, so one or two physical characteristics might help identify them despite who they claim to be.
*/
alter table agent
    modify first_name varchar(50) not null,
    modify last_name varchar(50) not null,
    add column height_in_inches int not null;
-- The modify clause specifies a column name and then redefines the column's data type, nullability, and defaults.
-- The add column clause creates a new column from scratch.
-- ****************************************************** More Tables *************************************************************
/*
Create an alias table with the create table statement. 
An agent has a one-to-many relationship with an alias. 
One agent can have zero or more aliases.

An alias should include columns for a:
	- unique identifier
	- name
	- persona: the alias's backstory
Decide which primary and foreign keys are needed to represent the relationship.
*/

-- Creating Mission (one-to-many relationship with (agency/mission))
create table mission (
    mission_id int primary key auto_increment,
    code_name varchar(50) not null,
    notes text,
    start_date date not null,
    projected_end_date date not null,
    actual_end_date date null,
    operational_cost decimal(10,2) not null,
    agency_id int not null,
    constraint fk_mission_agency_id
        foreign key(agency_id)
        references agency(agency_id)
);

-- Zero or more agents can be assigned to a mission. 
-- The mission/agent relationship is many-to-many. 
-- The mission_agent table is a bridge table. 
-- We use a compound mission_id/agent_id primary key to prevent duplicate assignments.
create table mission_agent (
    mission_id int not null,
    agent_id int not null,
    constraint pk_mission_agent 
        primary key(mission_id, agent_id),
    constraint fk_mission_agent_mission_id
        foreign key (mission_id)
        references mission(mission_id),
    constraint fk_mission_agent_agent_id
        foreign key (agent_id)
        references agent(agent_id)
);
-- *************************************************** Security Clearance *********************************************************
-- A security clearance record includes an id and a name.
-- Sample security clearance names: Confidential, Secret, Top Secret, USAP (Unacknowledged Special Access Program), FYEO (For Your Eyes Only).
create table security_clearance (
    security_clearance_id int primary key auto_increment,
    `name` varchar(50) not null
);

-- Security clearance is part of the agency/agent relationship. 
-- An agent is given a security clearance designation in the context of agency secrets. 
-- We need to alter the agency_agent table to include a security clearance.
-- Newest MySQL
alter table agency_agent
    add column security_clearance_id int not null,
    add constraint fk_agency_agent_security_clearance_id
         foreign key (security_clearance_id)
         references security_clearance(security_clearance_id);

-- Older versions of MySQL can't use the `constraint` form.
-- Use the `foreign key` form instead:
alter table agency_agent
    add column security_clearance_id int not null,
    add foreign key fk_agency_agent_security_clearance_id (security_clearance_id)
         references security_clearance(security_clearance_id);
-- ****************************************************** Final Schema ************************************************************
-- During initial schema development, it's not necessary to alter tables (though alter is a good statement to know). 
-- We drop the database and update to the latest design.

-- The final field_agent schema script:
drop database if exists field_agent;
create database field_agent;
use field_agent;

-- create tables and relationships
create table agency (
    agency_id int primary key auto_increment,
    short_name varchar(25) not null,
    long_name varchar(250) not null
);

create table location (
    location_id int primary key auto_increment,
    `name` varchar(25) not null,
    address varchar(125) not null,
    city varchar(50) not null,
    country_code varchar(5) not null,
    postal_code varchar(15) not null,
    agency_id int not null,
    constraint fk_location_agency_id
        foreign key (agency_id)
        references agency(agency_id)
);

create table agent (
    agent_id int primary key auto_increment,
    first_name varchar(50) not null,
    middle_name varchar(50) null,
    last_name varchar(50) not null,
    dob date null,
    height_in_inches int not null
);

create table security_clearance (
    security_clearance_id int primary key auto_increment,
    `name` varchar(50) not null
);

create table mission (
    mission_id int primary key auto_increment,
    code_name varchar(50) not null,
    notes text,
    start_date date not null,
    projected_end_date date not null,
    actual_end_date date null,
    operational_cost decimal(10,2) not null,
    agency_id int not null,
    constraint fk_mission_agency_id
        foreign key(agency_id)
        references agency(agency_id)
);

create table agency_agent (
    agency_id int not null,
    agent_id int not null,
    identifier varchar(50) not null,
    security_clearance_id int not null,
    activation_date date not null,
    is_active bit not null default 1,
    constraint pk_agency_agent
        primary key (agency_id, agent_id),
    constraint fk_agency_agent_agency_id
        foreign key (agency_id)
        references agency(agency_id),
    constraint fk_agency_agent_agent_id
        foreign key (agent_id)
        references agent(agent_id),
    constraint fk_agency_agent_security_clearance_id
        foreign key (security_clearance_id)
        references security_clearance(security_clearance_id),
    constraint uq_agency_agent_identifier_agency_id
        unique (identifier, agency_id)
);

create table mission_agent (
    mission_id int not null,
    agent_id int not null,
    constraint pk_mission_agent 
        primary key(mission_id, agent_id),
    constraint fk_mission_agent_mission_id
        foreign key (mission_id)
        references mission(mission_id),
    constraint fk_mission_agent_agent_id
        foreign key (agent_id)
        references agent(agent_id)
);

create table alias (
    alias_id int primary key auto_increment,
    `name` varchar(125) not null,
    persona varchar(2048) null,
    agent_id int not null,
    constraint fk_alias_agent_id
        foreign key (agent_id)
        references agent(agent_id)
);

-- Be sure to follow the diagrams as a means of better understanding how the code works!
-- ****************************************************** UNDERSTAND **************************************************************
/*
1. Why is it important to specify null/not null in a column definition?
	- NULL means you do not have to provide a value for the field
    - NOT NULL means you must provide a value for the fields.
2. How would you design a table with a self-referential relationship (a row in the table has a reference to another row in the same table)? Write the DDL.
	- TBA
3. What is the maximum number of column definitions allowed inside a create table statement?
	- 65,535 bytes
4. Is it better to alter table for changes or drop everything and start over?
	- alter tables for changes. Dropping tables should primarily be used for things such as testing
*/
-- ********************************************************** END *****************************************************************